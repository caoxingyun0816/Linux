门面模式
提供一个统一的接口去访问多个子系统的多个不同的接口，它为子系统中的一组接口提供一个统一的高层接口。使用子系统更容易使用。
本质：就是化零为整；引入一个中介类，把各个分散的功能组合成一个整体，只对外暴露一个统一的接口；

这两年流行微服务，即化整为零，把一个大服务拆分成一个个零部件； 
而门面模式则是反其道，是化零为整；

引入一个第三方中介类，这个类集合了多个零部件类的功能，实际功能则委托给这些零部件对象，这个类只是做为对外的统一接口，只是一个马甲

门面模式只是将客户端与子系统隔离，结构图如下

client --> facade   -->subsystema
				    -->subsystemb
				    -->subsystemc

角色：

外观角色（Facade）：是模式的核心，他被客户client角色调用，知道各个子系统的功能。同时根据客户角色已有的需求预订了几种功能组合\
子系统角色（Subsystem classes）：实现子系统的功能，并处理由Facade对象指派的任务。对子系统而言，facade和client角色是未知的，没有Facade的任何相关信息；即没有指向Facade的实例。
客户角色（client）：调用facade角色获得完成相应的功能。

门面模式总结
优势：

使客户端和子系统隔离，客户端代码变得很简单，不需要跟多个子系统进行关联。
子系统的变化不会影响客户端的代码。
子系统直接松耦合，一个系统的修改对其他系统没有影响。
劣势：

增加新的子类系统需要可能需要修改外观类的源码，违背开闭原则。

使用场景
当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式。
客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性。
在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。


现实案例
spring ApplicationContext; 
它实现了Factory、ResourceLoader等接口，并通过引用这些接口的实例，对外统一提供：加载配置、解析资源、创建Bean、提供环境、启动流程等功能；

客户代码只需要操作context就可以获取spring的提供的功能，而无需关心内部的细节

与代理模式的区别” 
在了解门面模式时，会发现它不仅与代理模式很像，与装饰器模式也很类似； 
它们之间到底有什么样的区别呢?

相似点： 
- 都引入了中介类（对象） 
- 中介对象都引用并把功能委托给了原对象 
- 都起到了”代理”功能

区别 
- 代理侧重于对原对象的访问控制（当然也可以不是控制而是功能增强） 
- 代理与原类实现相同的抽象（相同接口或直接继承原业） 
- 代理只代理一个类 
- 门面侧重于功能整合（多个小系统或小对象整合成一个功能丰富的大对象） 
- 门面可以与子系统具有不同的抽象（具有不同的接口，可以对方法重新起名） 
- 门面代理的是一系列类

抽象外观类的引入：
外观模式最大的缺点在于违背了“开闭原则”，
当增加新的子系统或者移除子系统时需要修改外观类，可以通过引入抽象外观类在一定程度上解决该问题，客户端针对抽象外观类进行编程。对于新的业务需求，不修改原有外观类，而对应增加一个新的具体外观类，由新的具体外观类来关联新的子系统对象，同时通过修改配置文件来达到不修改源代码并更换外观类的目的。 


log4j 原理
org/slf4j/impl/StaticLoggerBinder.class

getLogger的时候会去classpath下找STATIC_LOGGER_BINDER_PATH，STATIC_LOGGER_BINDER_PATH值为"org/slf4j/impl/StaticLoggerBinder.class"，即所有slf4j的实现，在提供的jar包路径下，一定是有"org/slf4j/impl/StaticLoggerBinder.class"存在的


对于有些接口的扩展实现,不同的实现，由于代码中写死了类的路径，自己在实现接口的时候也要创建相同的包和类
然后再重写方法。

在开放的系统中，对某个接口的实现类进行初始化时，可以先获取所有实现了某个接口的实现类。如果该实现类唯一，则直接实例化。如果不唯一，则可以读取配置文件，按配置文件的配置进行实例化。从而达到了：定义接口 -> 给出实现类 -> 其它用户按接口规范自定义实现类 -> 配置实现类 -> 调用用户自定义实现类的目的。

idea